# 此文件定义Accretion的整体设计思路
# 语法类似于features_demo.md中所描述的, 但更为简洁
# 以 "*" 开头的行为一个概念的描述
# 以 "* [" 开头的行则代表一个可开发的特性, []中的特性标识见features_demo.md
# 缩进体现逻辑层次
# 以:cite结尾的特性引用了同样文字内容的以:ref结尾的特性
# 所有这些描述和特性加在一起, 构成了Accretion系统

* 技术、性能、安全问题一般性讨论
  * 此系统仅供个人使用, 不建议大量用户同时使用, 见以下的性能和安全分析
  * 系统性能分析
    * 所有设计以方便个人用户使用为第一原则, 由此产生的额外性能损耗可以接受
    * 程序运行的目标计算机大概就是普通家用机或笔记本, 开发时注意控制内存消耗, 以满足大部分用户
  * 系统安全模型
    * 此系统应该运行于全盘加密的安全的个人电脑或服务器上
      * 一个人的知识结构可以很大程度的反映这个人的喜好、性格、世界观等, 可以说是最私密的信息
        * 知识有可以公开的与不适合公开的部分
          * 不适合公开的知识举例:
            * 传染病相关信息: 会引起各种歧视。但是本人还是需要这部分知识来进行治疗、维持健康
            * 各种取向: 会引起各种歧视。但是本人还是需要这部分知识来更好地了解自己
            * 信仰: 有些信仰在那个人所处的环境中不适合公开, 甚至要严格保密, 否则后果严重
            * 其他各种你懂的和你不懂的
              * 每个人一生中接触到的知识甚至知识类型都是有限的
              * 有些东西在你接触前是完全无法想象的, 所谓打开了新世界的大门
            * 不跟杠精杠: 所有的歧视都是客观存在的, 无论平权运动进展多顺利
          * 知乎最让人讨厌的一点就是公开了一个人所有动态。我会使用匿名小号来关注我真正需要的知识
        * 我们会公开可公开的知识, 以吸引志趣相投者
        * 我们也会收集不适合公开的知识, 有一些知识对我们来说也很重要, 甚至是必不可少的
        * 整个知识管理系统, 应该作为自己的个人隐私, 放置在自己完全可控、安全的环境中
          * 以此为前提, 程序开发中不会引入多余的安全措施
    * 后端部分仅向本地或者安全的局域网提供服务, 严禁用于公网, 原因如下
      * 此系统前端部分极度的开放, 会产生大量的注入点
      * 后端部分对前端仅进行'typo'程度的内容过滤, 可能被精心构造的payload攻陷
      * 此系统以用户用的舒服为第一要素, 以此为基础的安全模型会非常的复杂, 甚至会出现安全模块的代码长度超过业务本身
        * 目前开发组没有精力去研究这一部分, 也没有计划去研究
        * 所有额外的没有必要的安全特性都会被拒绝掉
  * 结合以上两点, 为什么现在市面上没有非常灵活的知识管理系统呢?
    * 主要问题是安全性、稳定性和性能
    * 一个新功能, 十个新Bug, 数个想得到的和想不到的安全漏洞
    * 如果是云笔记之类的, 随着用户数量增多, 需要一些性能优化, 可能会牺牲一些用户体验
    * 商用软件必须保证稳定, 之后才是增加新功能
  * 本系统通过限制程序的运行环境来规避复杂的安全和性能模型, 专注于实现各种花哨的功能
  * 如何远程使用此系统？
    * 通过使用ssh端口转发或者自己搭建VPN
      * 用户需要有固定IP(比如放在机构的电脑)或者通过路由器自行实现动态域名
      * 这需要用户有一定的网络基础
      * 对于普通的用户, 建议仅在本地使用
    * 另外可通过微信机器人和Telegram机器人远程发送指令, 让后端收集一些信息
      * 这个功能不需要有固定IP
      * 微信机器人需要用户有可以网页登录的微信小号
      * Telegram机器人可以使用用户的大号或者小号
      * 所有登录session都在用户自己的掌握中, 没有安全性问题
  * 系统会提供移动端APP么? 不会, 理由如下
    * 程序的前端其实就是一个网页APP, 可以直接在手机浏览器中访问(安全局域网模式)
      * 开发时加入响应式的前端页面, 优化移动端的体验(此功能开发优先级较低)
    * 远程收集、收藏功能通过微信、tg机器人实现
      * 具体操作是把链接分享给这些机器人
    * 没有开发APP的必要
  * 系统除了爬虫模块外, 均不与公网进行通讯(这是必要的安全措施, 可一定程度防止工具链攻击)
    * 爬虫模块独立于后端部分运行单独的服务
    * 爬虫模块通过后端API与后端进行通讯
    * 防火墙关闭后端访问公网的权限, 仅开通爬虫访问公网的权限
    * 爬虫模块放置于沙盒中, 限制其文件访问权限
      * 有效的文件访问都交给后端, 而后端没有网络访问权限
      * 一般的工具链攻击都是基于库, 广撒网, 网络权限与文件权限分离可一定程度防御这些
  * pull request的接受
    * 整个系统会设计成高度模块化的, 接受用户的插件pull request申请
    * 前端、主题等不容易产生安全新问题的部分审核较快
    * 后端, 特别是有网络交互方面的爬虫模块, 需要进行认真的代码审查
      * 要求开发者们提供详细的注释来说明代码的行为
  * 开发组成员
    * 目前来说只有我一个
    * 出于安全考虑(参考18年的event-stream事件)
      * 新加入的开发者需与本人面基(或skype), 相互交换最基本的身份信息, 且同意上述软件开发的整体设计思路
      * 开发这套系统首先要对用户的信息安全负责(开发者本人就是重度用户), 所以需要如此慎重的操作
  * 想到其他的再写
* 技术栈选择和讨论
  * 后端
    * nuxt.js(express.js): 框架
      * passportjs: 用于认证的中间件
      * mongoose: mongodb模型的面向对象化
    * monodb: 数据库
  * 前端
    * vue
      * nuxt: 前端的服务器渲染
      * vue 3.0 发布后尽快迁移
  * 开发环境
    * OSX或linux + Chrome
* 版本号说明
  * 版本号分为四级1.2.3.4
    * 第一级版本号:
      * v1.0正式向公众推送: 完成Horizon, Brainhole 和 Inflow
      * v2.0完成现在所有设想的功能: Lightcone和Outflow
    * 二级版本号:
      * 完成重要模块:
        * [ ] 后端API和前端搜索界面完成后为v0.1
    * 三级版本号:
      * 完成模块中某个函数或者功能
    * 四级版本号:
      * 正式上线后的各种热补丁
      * 各种需要发布的小改动
* 开发产生的其他通用库
  * [f] reconnectws: 一个websocket自动重连的库,可同时用于前端和后端
  * [ ] ac-table: 一个可视化json数组的vue表格模块
    * 提供一个可以开关的控制台
      * [ ] 用于控制显示哪些字段
        * 因为每一个json中的字段不一定一样, 而且有的时候只想看某些字段
      * [ ] 控制台的字段配置等设置选项可以导入和导出
      * [ ] 可以通过拖拽这些字段实现列顺序的交换
    * 高级表头
      * [ ] 拖拽表头改变列顺序
      * [ ] 单击表头实现按此列排序
        * 可通过额外的信息判定某个字段的类型, 比如按字符排序和按数字大小排序结果不一样
        * 默认都按字符排序, 除非此列特别指定为其他格式
      * [ ] 实现按多列排序
        * 需要琢磨一下这个功能的交互方式
      * [ ] 每个表头可以增加filter和其各种逻辑组合
        * 所有中文自动生成其相应拼音, 增加filter时无需切换输入法
        * filter支持
          * 普通搜索
          * 正则搜索
          * LiquidMetal: 此filter同时实现了过滤和排序, 与其他字段的排序互斥
    * 行所带有的功能:
      * [ ] 鼠标指向行的高亮
      * [ ] 提供多行选择模式(控制台开启此功能)
        * 选择的数据可导出
      * [ ] 行展开功能(控制台开启此功能)
        * 展开后, 显示列中没有展示的数据
        * 或者显示其他的数据(行为在控制台中选择)
  * [ ] ac-editor: 文章浏览主窗口
    * [ ] 支持源文件、富文本、宣传结果的快速切换或者分栏对照
      * [ ] 源文件支持Markdown和HTML两种
    * 其他功能待添加
* [d] Brainhole: 后端系统
  prop:
    desc: 数据库、网页、API后端
  * [d] 基本的管理界面和登录界面
  * 提供API服务
    * [d] 提供REST接口的API
      * [d] API认证接口
    * [d] 提供ws接口的API
    * [d] API的unittest
    * [ ] 基于ws的前端搜索实时补全推送接口:ref
  * 数据库模式设计
    * [d] 设计合理的“注入”手段来在mongodb中维护关系模型
    * 可管理的信息类型:
      * [d] 文章: 各种基于网页的博文等
      * [d] 浏览器书签
      * [d] 代码片段
      * 与本地文件相关
        * [ ] 出于安全考虑, 后端所管理的文件必须放在某个目录下
          * 后端只能操作这个目录下的内容, 禁止访问和修改这个目录外的内容
        * [d] 书籍: 本地pdf索引
        * [d] 文件: 与本地文件向连接
    * [ ] 提供方便的接口, 用于用户自定义新类型的可管理信息
      * tags, catalogues, metadatas, flags等可以通过简单的配置注入到这些自定义模型中
    * Relation相关:
      * [d] 父子关系的添加修改等需要检测环路
    * Catalogue相关:
      * Catalogue包括真实的和虚拟的
        * 虚拟的Catalogue是一个查询语句
          * [ ] 设计其刷新机制(否则可能会刷新过多, CPU爆炸)
    * Event相关:
      * 字段设计:
        * addBy: 手动添加的？自动添加的？如果是自动添加的, 用的是哪个自动策略？
        * 前端展示的一些参数, 比如时间线颜色
        * define: 记录这个事件的原始定义信息
        * 时刻类和时段类事件
          * 对于时刻类事件只需要知道开始时刻就行了
            * 但是也要记录事件粒度类型（有的事件我只关心他发生在那一天, 有的事件需要精确到秒）
          * 对于时段类事件需要知道开始和结束时刻
            * 用户可输入（开始时刻, 结束时刻）, （开始时刻, 持续时间）, （结束时刻, 持续时间）等
            * 程序最终展示的时候用的是计算出来的(开始时刻, 结束时刻), 但是用户应该可以用任何方便的输入来定义这个事件
          * 对于重复类的时间（比如课程表）, 提供重复逻辑（星期一？跳过节假日？下班学期的课？）

  * Log信息
    * 作用: 各种使用的用户行为统计
    * 所有的用户操作:
      * [ ] 增删改脑洞, tags, catalogues, metadatas....等一切值得统计的行为都会生成一个Event
      * Event同样可以在Horizon中自行搜索
      * Event信息可在Lightcone中可视化
        * [ ] 基于ws向Lightcone实时推送
      * 用户可自行编写相关插件, 实现自身行为的统计和可视化
* Horizon: 前端系统
  * 搜索系统
    * [ ] 基于mongodb搜索语法
    * [ ] 对搜索的逻辑结构进行可视化
      * [ ] 常用搜索操作不需要鼠标的支持, 可通过键盘快速输入
        * [ ] 快捷键支持
        * [ ] 快速调整逻辑结构(这部分得靠鼠标了, 因为属于不常用功能)
      * [ ] 基于已完成部分的自动补全
        * [ ] 基于ws的前端搜索实时补全推送接口:cite
    * [ ] 搜索结构使用ac-table来展现
  * 导出系统
    * [ ] 将收集到的信息导出到静态HTML文件，通过需要认证的http服务等共享出去
  * 主页
    * 左侧边栏
      * [ ] 放置基于Catalogue, 父子关系, Crossref, Relation等信息的树状结构图
        * [ ] 可使用拖拽实现Catalogue的更改
          * [ ] 按住ctrl实现复制
        * [ ] 提供三种展示UI
          * [ ] 基本目录: 只能看到同级元素和..,类似于一般的文件浏览器
          * [ ] 树状展示: 左侧提供展开和关闭的按钮
          * [ ] MacOS的多子窗口展示: 用过Finder的都知道这个, 很好用的
          * [ ] 由于每个文章都可能属于不同的Catalogue, 提供快速跳转到同一文章在不同Catalogue下实例的功能
      * [ ] 侧边栏带有tab系统, 每个tab打开不同的catalogue作为root
    * 主工作区
      * 信息展示由ac-editor实现
    * 右侧边栏
      * [ ] 风箱式折叠UI
      * [ ] 基本信息展示区
      * [ ] 启发式的交互设计(对于标签系统、Metadata系统等)
      * [ ] 标签云系统
        * 依据标签关系
          * [ ] 自动标签添加系统
          * [ ] 标签联想系统
      * [ ] Metadata系统
      * [ ] Crossref系统
      * [ ] 关系系统
  * 全局设置
    * [ ] 提供用户自定义CSS配置的接口
* Inflow: 爬虫, 信息收集模块
  * 支持的类新
    * [ ] RSS协议
    * [ ] 普通网页
    * [ ] 微信公众号
  * [ ] 提供模板接口
  * [ ] 提供插件接口
  * 远程控制接口
    [ ] Telegram机器人
    [ ] 微信机器人
  * 安全相关:
    * [ ] 爬虫模块放置于沙盒中, 限制其文件访问权限
* Outflow: 分享系统
  * 将库内知识导出为离线html文件
* Lightcone: 时间、事件管理和可视化模块
  * 特性概述:
    * 支持的数据类型:
      * 时刻类数据: 我们只关心事件的开始时刻, 不关心或者不存在结束时刻
      * 时段类数据: 关心事件的开始事件和结束事件。例子：课程表里的某节课
    * 插入新事件：
      * 事件可以由程序自动插入或者手动插入, 例子们：
        * 我把这个系统当做课程表使用, 手动插入时段类事件
        * 我把这个系统当做流水账式的日记来使用, 手动插入时段类和时刻类的事件
        * Accretion 在添加新文章后自动插入时刻类事件, 这样我可以可视化的了解我今天(什么时间)学习(收集、整理)了哪些知识
      * 可以预定义事件模板：比如
        * 我把这个系统当做流水账式的日记使用, 记录自己的生活, 统计一下工作时间和娱乐时间之类的
        * 可以预定义『写程序』, 『逛B站』之类的事件, 到时候可以快速插入这些事件。
    * 不同的View（或者说Filter）:
      * 类似于数据库的View, 可以根据事件信息对展示出来的事件进行过滤, 比如:
        * 只展示Accretion自动添加的文章时刻类时间, 这个View用来可视化个人知识收集
        * 只展示手动添加的信息, 这个View用来记录个人日常生活流水账
      * Filter使用Mongodb查新语句的语法, 支持任意复杂逻辑
* 网站建设: Accretion网站的搭建
  prop:
    prio: 在Accretion的beta版发布之后着手开始设计
  * [ ] 域名购买: 待定
  * [ ] 基于electron的网站: 反正到时候肯定是个熟练工了, 随便找个模板用一用
    * [ ] 模板选择
    * [ ] 内容填充
* 宣传渠道:
  prop:
    prio: 在Accretion的beta版发布之后着手开始设计
  * bilibili: 在B站上上传简介视频, 用于宣传
    * [ ] 利用B站UP主的后台统计数据可以巧妙的完成一些调查问卷
    * [ ] 介绍Accretion整体设计哲学的视频
    * [ ] 介绍Inflow模块的视频
    * [ ] 介绍Horizon模块的视频
